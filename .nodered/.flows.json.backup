[
    {
        "id": "745006266a1bcda5",
        "type": "tab",
        "label": "Поток 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "d853c5ee2fe52d32",
        "type": "telegram bot",
        "botname": "node-red-bot",
        "usernames": "",
        "chatids": "",
        "baseapiurl": "",
        "testenvironment": false,
        "updatemode": "polling",
        "addressfamily": "4",
        "pollinterval": "2000",
        "usesocks": false,
        "sockshost": "",
        "socksprotocol": "socks5",
        "socksport": 6667,
        "socksusername": "anonymous",
        "sockspassword": "",
        "bothost": "",
        "botpath": "",
        "localbothost": "0.0.0.0",
        "localbotport": 8443,
        "publicbotport": 8443,
        "privatekey": "",
        "certificate": "",
        "useselfsignedcertificate": false,
        "sslterminated": false,
        "verboselogging": false
    },
    {
        "id": "ws_server_config",
        "type": "websocket-listener",
        "path": "/ws/chat",
        "wholemsg": "false"
    },
    {
        "id": "telegram_receiver",
        "type": "telegram receiver",
        "z": "745006266a1bcda5",
        "name": "Telegram receiver",
        "bot": "d853c5ee2fe52d32",
        "saveDataDir": "",
        "filterCommands": true,
        "x": 120,
        "y": 160,
        "wires": [
            [
                "process_telegram_message"
            ],
            [
                "process_callback_query"
            ]
        ]
    },
    {
        "id": "http_chat",
        "type": "http in",
        "z": "745006266a1bcda5",
        "name": "HTTP Chat Endpoint",
        "url": "/api/chat",
        "method": "post",
        "upload": true,
        "swaggerDoc": "",
        "x": 110,
        "y": 260,
        "wires": [
            [
                "process_http_message"
            ]
        ]
    },
    {
        "id": "websocket_in",
        "type": "websocket in",
        "z": "745006266a1bcda5",
        "name": "WebSocket In",
        "server": "ws_server_config",
        "client": "",
        "x": 110,
        "y": 380,
        "wires": [
            [
                "process_websocket_message"
            ]
        ]
    },
    {
        "id": "process_telegram_message",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Process Telegram Message",
    "func": "const content = msg.payload.content || msg.payload.text || msg.payload;\nconst chatId = msg.payload.chatId || msg.payload.chat?.id;\nconst updateId = msg.payload.update_id;\nconst isFromUser = !msg.payload.from?.is_bot;\n\nif (!content || !chatId) {\n    return null;\n}\n\n// Храним обработанные update_id для каждого chatId (в памяти узла)\nif (!context.get('processedUpdates')) context.set('processedUpdates', {});\nconst processedUpdates = context.get('processedUpdates');\n\n// Проверка на команду /start с дедубликацией и фильтром источника\nif (content.trim() === '/start' && isFromUser) {\n    if (!processedUpdates[chatId] || processedUpdates[chatId] !== updateId) {\n        processedUpdates[chatId] = updateId;\n        msg.payload = {\n            chatId: chatId,\n            type: 'message',\n            content: 'Добро пожаловать! Это юридический бот, который помогает с вопросами об интеллектуальной собственности на основе Гражданского кодекса Украины. Задайте свой вопрос или выберите опцию из меню.',\n            options: {\n                reply_markup: {\n                    inline_keyboard: [\n                        [\n                            { text: 'Задать вопрос', callback_data: 'ask_question' },\n                            { text: 'О проекте', callback_data: 'about_project' }\n                        ]\n                    ]\n                }\n            },\n            final: true\n        };\n        return [null, msg];\n    }\n    return null; // Игнорируем дубликаты\n}\n\n// Проверка на обрезанный или слишком короткий запрос\nif (content.length < 10) {\n    msg.payload = {\n        chatId: chatId,\n        type: 'message',\n        content: 'Пожалуйста, уточните ваш вопрос.',\n        final: true\n    };\n    return [null, msg];\n}\n\nconst userName = msg.payload.from?.first_name || msg.payload.from?.username || 'User';\n\n// Сначала отправляем лоадер через второй выход\nconst loaderMsg = {\n    chatId: chatId,\n    type: 'message',\n    content: 'Ожидайте, обрабатываю ваш запрос...',\n    options: { reply_markup: { remove_keyboard: true } },\n    final: false\n};\n\n// Основное сообщение для обработки\nmsg.chatId = chatId;\nmsg.userName = userName;\nmsg.originalMessage = content;\nmsg.source = 'telegram';\nmsg.payload = {\n    message: content,\n    chatId: chatId,\n    userName: userName,\n    timestamp: new Date().toISOString()\n};\n\nreturn [msg, { payload: loaderMsg }];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 120,
        "wires": [
            [
                "pinecone_search"
            ],
            [
                "a00c6cec1ed3f802"
            ]
        ]
    },
    {
        "id": "process_callback_query",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Process Callback Query",
        "func": "if (msg.payload.type === 'callback_query') {\n    const callbackData = msg.payload.data;\n    const chatId = msg.payload.chatId || msg.payload.chat?.id;\n\n    let responseText = '';\n    if (callbackData === 'ask_question') {\n        responseText = 'Задайте ваш вопрос, и я помогу найти ответ на основе Гражданского кодекса Украины!';\n    } else if (callbackData === 'about_project') {\n        responseText = 'Этот проект — юридический бот, созданный для помощи в вопросах интеллектуальной собственности. Использует RAG с Pinecone и локальную модель GPT для точных ответов.';\n    } else {\n        responseText = 'Неизвестная команда.';\n    }\n\n    msg.payload = {\n        chatId: chatId,\n        type: 'message',\n        content: responseText\n    };\n\n    // Ответ на callback_query, чтобы убрать \"часики\" в Telegram\n    msg.callback_query_response = {\n        callback_query_id: msg.payload.id\n    };\n\n    return msg;\n}\n\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 180,
        "wires": [
            [
                "new_loader_function"
            ]
        ]
    },
    {
        "id": "process_http_message",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Process HTTP Message",
        "func": "const userMessage = msg.payload.message || '';\n\nif (!userMessage) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'No message provided' };\n    return [null, msg];\n}\n\nmsg.originalMessage = userMessage;\nmsg.source = 'http';\nmsg.payload = {\n    message: userMessage,\n    timestamp: new Date().toISOString()\n};\n\nreturn [msg, null];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 260,
        "wires": [
            [
                "pinecone_search"
            ],
            [
                "http_error_response"
            ]
        ]
    },
    {
        "id": "process_websocket_message",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Process WebSocket Message",
        "func": "try {\n    let data = msg.payload;\n    if (typeof data === 'string') {\n        data = JSON.parse(data);\n    }\n    \n    const userMessage = data.message || '';\n    \n    if (!userMessage) {\n        return null;\n    }\n    \n    msg.originalMessage = userMessage;\n    msg.source = 'websocket';\n    msg.sessionId = data.sessionId || 'ws-' + Date.now();\n    \n    msg.payload = {\n        message: userMessage,\n        sessionId: msg.sessionId,\n        timestamp: new Date().toISOString()\n    };\n    \n    return msg;\n} catch (error) {\n    node.error('WebSocket parse error: ' + error.message, msg);\n    return null;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 380,
        "wires": [
            [
                "pinecone_search"
            ]
        ]
    },
    {
        "id": "pinecone_search",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Prepare Pinecone Query",
        "func": "msg.payload = {\n    messages: [\n        {\n            role: 'user',\n            content: msg.originalMessage\n        }\n    ],\n    stream: false,\n    model: 'gpt-4o'\n};\n\nmsg.headers = {\n    'Api-Key': env.get('PINECONE_API_KEY') || 'pcsk_TQZJm_NzgRXEUsaX3bVkQ4DJy7fWFshLCkpm1xDKRPtuV2QpKs8WBm1ZVxaAGpqXGYcFp',\n    'Content-Type': 'application/json'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 240,
        "wires": [
            [
                "pinecone_request"
            ]
        ]
    },
    {
        "id": "pinecone_request",
        "type": "http request",
        "z": "745006266a1bcda5",
        "name": "Pinecone Vector Search",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://prod-1-data.ke.pinecone.io/assistant/chat/demo1",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": true,
        "headers": [],
        "x": 710,
        "y": 520,
        "wires": [
            [
                "check_pinecone_response",
                "2b88f482470a39b0"
            ]
        ]
    },
    {
        "id": "check_pinecone_response",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Check Pinecone Response",
        "func": "if (msg.payload.message && msg.payload.message.content && msg.payload.message.content.length > 100) {\n    msg.payload.response = msg.payload.message.content;\n    return [null, msg];\n} else {\n    return [msg, null];\n}",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1020,
        "y": 400,
        "wires": [
            [
                "prepare_ollama_request",
                "2b88f482470a39b0"
            ],
            [
                "route_response"
            ]
        ]
    },
    {
        "id": "prepare_ollama_request",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Prepare Ollama Request",
        "func": "const pineconeResponse = msg.payload;\nlet vectorContext = '';\n\n// Извлекаем контекст из ответа Pinecone\nif (pineconeResponse && pineconeResponse.message && pineconeResponse.message.content) {\n    vectorContext = pineconeResponse.message.content;\n} else {\n    node.warn('Не удалось извлечь контекст из Pinecone: ' + JSON.stringify(pineconeResponse));\n}\n\n// Усиленный промпт для строгого следования контексту\nconst systemPrompt = 'Ты — юридический помощник. Ответь на вопрос ТОЛЬКО на основе предоставленного контекста. Не добавляй информацию из своих знаний. Если контекст не содержит ответа, напиши: \"Нет достаточной информации в контексте.\" Ответь на русском языке, кратко и точно.';\n\nconst contextPrompt = vectorContext ? 'Контекст (используй ТОЛЬКО это):\\n' + vectorContext + '\\n\\n' : 'Нет контекста.\\n\\n';\nconst userQuestion = 'Вопрос: ' + msg.originalMessage;\n\nconst fullPrompt = systemPrompt + '\\n\\n' + contextPrompt + userQuestion;\n\n// Логируем полный промпт для отладки\nnode.warn('Полный промпт Ollama: ' + fullPrompt);\n\nconst ollamaModel = env.get('OLLAMA_MODEL') || 'gpt-oss:20b';\n\nmsg.payload = {\n    model: ollamaModel,\n    prompt: fullPrompt,\n    stream: false,\n    options: {\n        temperature: 0.1,\n        top_p: 0.6,\n        num_predict: 400\n    }\n};\n\nmsg.headers = {\n    'Content-Type': 'application/json'\n};\n\nmsg.vectorContext = vectorContext;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 280,
        "wires": [
            [
                "ollama_request",
                "f16a7ccde242a27a"
            ]
        ]
    },
    {
        "id": "ollama_request",
        "type": "http request",
        "z": "745006266a1bcda5",
        "name": "Ollama Local LLM",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://192.168.50.250:11434/api/generate",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": true,
        "headers": [],
        "x": 1330,
        "y": 280,
        "wires": [
            [
                "route_response",
                "90a24e86e3943698"
            ]
        ]
    },
    {
        "id": "route_response",
        "type": "switch",
        "z": "745006266a1bcda5",
        "name": "Route Response",
        "property": "source",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "telegram",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "http",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "websocket",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1590,
        "y": 300,
        "wires": [
            [
                "format_telegram_response"
            ],
            [
                "format_http_response"
            ],
            [
                "format_websocket_response"
            ]
        ]
    },
    {
        "id": "format_telegram_response",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Format Telegram Response",
        "func": "let aiResponse = '';\n\nif (msg.payload && msg.payload.response) {\n    aiResponse = msg.payload.response;\n} else if (msg.payload && msg.payload.text) {\n    aiResponse = msg.payload.text;\n} else {\n    aiResponse = 'Извините, не удалось получить ответ.';\n}\n\nmsg.payload = {\n    chatId: msg.chatId,\n    type: 'message',\n    content: aiResponse,\n    final: true\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 220,
        "wires": [
            [
                "new_loader_function"
            ]
        ]
    },
    {
        "id": "format_http_response",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Format HTTP Response",
        "func": "let aiResponse = '';\n\nif (msg.payload && msg.payload.response) {\n    aiResponse = msg.payload.response;\n} else {\n    aiResponse = 'Извините, не удалось получить ответ.';\n}\n\nmsg.payload = {\n    response: aiResponse,\n    timestamp: new Date().toISOString(),\n    originalQuestion: msg.originalMessage,\n    status: 'success',\n    model: 'ollama',\n    hasVectorContext: !!msg.vectorContext\n};\n\nmsg.statusCode = 200;\nmsg.headers = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type, Authorization'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 300,
        "wires": [
            [
                "http_response"
            ]
        ]
    },
    {
        "id": "format_websocket_response",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Format WebSocket Response",
        "func": "let aiResponse = '';\n\nif (msg.payload && msg.payload.response) {\n    aiResponse = msg.payload.response;\n} else {\n    aiResponse = 'Извините, не удалось получить ответ.';\n}\n\nmsg.payload = JSON.stringify({\n    type: 'chat_response',\n    response: aiResponse,\n    timestamp: new Date().toISOString(),\n    originalQuestion: msg.originalMessage,\n    sessionId: msg.sessionId,\n    status: 'success'\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 380,
        "wires": [
            [
                "websocket_out"
            ]
        ]
    },
    {
        "id": "new_loader_function",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Handle Loader",
        "func": "if (msg.payload.type === 'message' && !msg.payload.final) {\n    // Отправка лоадера\n    msg.payload.options = msg.payload.options || {};\n    msg.payload.options.reply_markup = { remove_keyboard: true }; // Убираем предыдущие кнопки\n    msg.payload.content = 'Ожидайте, обрабатываю ваш запрос...';\n    const loaderMsg = { ...msg.payload, message_id: null, temp: true };\n    context.set('loaderMsg_' + msg.payload.chatId, loaderMsg);\n    return [loaderMsg];\n} else if (msg.payload.type === 'message' && msg.payload.final) {\n    // Обновление сообщения с реальным ответом\n    const loaderMsg = context.get('loaderMsg_' + msg.payload.chatId);\n    if (loaderMsg) {\n        msg.payload.chatId = loaderMsg.chatId;\n        msg.payload.options = msg.payload.options || {};\n        msg.payload.options.reply_to_message_id = loaderMsg.message_id;\n        return [msg];\n    }\n    return [msg]; // Если лоадер не был отправлен\n} else {\n    return [msg]; // Остальные случаи\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1900,
        "y": 120,
        "wires": [
            [
                "a00c6cec1ed3f802"
            ]
        ]
    },
    {
        "id": "a00c6cec1ed3f802",
        "type": "telegram sender",
        "z": "745006266a1bcda5",
        "name": "Telegram sender",
        "bot": "d853c5ee2fe52d32",
        "haserroroutput": false,
        "outputs": 1,
        "x": 2100,
        "y": 180,
        "wires": [
            [
                "07232592a2a08e5d"
            ]
        ]
    },
    {
        "id": "http_response",
        "type": "http response",
        "z": "745006266a1bcda5",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 2060,
        "y": 300,
        "wires": []
    },
    {
        "id": "websocket_out",
        "type": "websocket out",
        "z": "745006266a1bcda5",
        "name": "WebSocket Out",
        "server": "ws_server_config",
        "client": "",
        "x": 2060,
        "y": 380,
        "wires": []
    },
    {
        "id": "http_error_response",
        "type": "http response",
        "z": "745006266a1bcda5",
        "name": "HTTP Error Response",
        "statusCode": "",
        "headers": {},
        "x": 2060,
        "y": 460,
        "wires": []
    },
    {
        "id": "07232592a2a08e5d",
        "type": "debug",
        "z": "745006266a1bcda5",
        "name": "Debug Telegram",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2240,
        "y": 120,
        "wires": []
    },
    {
        "id": "catch_errors",
        "type": "catch",
        "z": "745006266a1bcda5",
        "name": "Global Error Handler",
        "scope": [
            "pinecone_request",
            "ollama_request"
        ],
        "uncaught": true,
        "x": 1490,
        "y": 480,
        "wires": [
            [
                "format_error_response"
            ]
        ]
    },
    {
        "id": "format_error_response",
        "type": "function",
        "z": "745006266a1bcda5",
        "name": "Format Error Response",
        "func": "const errorMessage = msg.error ? msg.error.message : 'Unknown error';\nnode.error(errorMessage, msg);\n\nif (msg.source === 'telegram') {\n    msg.payload = {\n        chatId: msg.chatId,\n        type: 'message',\n        content: 'Произошла ошибка. Попробуйте позже.'\n    };\n    return [msg, null, null];\n}\n\nif (msg.source === 'http') {\n    msg.payload = {\n        error: 'Internal server error',\n        message: errorMessage,\n        timestamp: new Date().toISOString(),\n        status: 'error'\n    };\n    msg.statusCode = 500;\n    return [null, msg, null];\n}\n\nif (msg.source === 'websocket') {\n    msg.payload = JSON.stringify({\n        type: 'error',\n        error: 'Internal server error',\n        timestamp: new Date().toISOString(),\n        sessionId: msg.sessionId\n    });\n    return [null, null, msg];\n}\n\nreturn [null, null, null];",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1750,
        "y": 480,
        "wires": [
            [
                "new_loader_function"
            ],
            [
                "http_error_response"
            ],
            [
                "websocket_out"
            ]
        ]
    },
    {
        "id": "90a24e86e3943698",
        "type": "debug",
        "z": "745006266a1bcda5",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1520,
        "y": 160,
        "wires": []
    },
    {
        "id": "2b88f482470a39b0",
        "type": "debug",
        "z": "745006266a1bcda5",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 520,
        "wires": []
    },
    {
        "id": "f16a7ccde242a27a",
        "type": "debug",
        "z": "745006266a1bcda5",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 220,
        "wires": []
    }
]